---
title: "MIT6.828 — Lab 1: Booting a PC"
author: 刘冰
date: 2019-04-07
slug: mit-6.828-lab1
categories:
  - OS
tags: ["6.828", "MIT", "Bootloader", "QEMU", "ELF", "STAB"]
---

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1671.4">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Songti SC'}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px 'Songti SC'}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 12.0px 'PingFang SC Semibold'; color: #000000; -webkit-text-stroke: #000000}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px 'Songti SC'; -webkit-text-stroke: #000000}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Songti SC'; -webkit-text-stroke: #000000}
    p.p11 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; -webkit-text-stroke: #000000; min-height: 13.0px}
    p.p12 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; -webkit-text-stroke: #000000}
    p.p14 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; color: #fb0017; -webkit-text-stroke: #000000}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px 'Songti SC'; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; color: #fb0017; -webkit-text-stroke: #000000}
    p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Helvetica; -webkit-text-stroke: #000000}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px 'Songti SC'; color: #fb0017; -webkit-text-stroke: #000000}
    p.p22 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; min-height: 13.0px}
    p.p23 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo}
    p.p24 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; color: #fb0017}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 13.0px 'Songti SC'; -webkit-text-stroke: #000000}
    p.p28 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p29 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px 'PingFang SC'; -webkit-text-stroke: #000000}
    p.p30 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p31 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px 'PingFang SC'}
    p.p32 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000; min-height: 18.0px}
    p.p33 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 13.0px 'Songti SC'; color: #000000; -webkit-text-stroke: #000000}
    li.li1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Songti SC'}
    li.li3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    li.li8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000}
    li.li9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Songti SC'; -webkit-text-stroke: #000000}
    li.li10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo; -webkit-text-stroke: #000000}
    li.li15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Songti SC'; color: #000000; -webkit-text-stroke: #000000}
    li.li25 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 13.0px 'Songti SC'; -webkit-text-stroke: #000000}
    li.li26 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 13.0px Palatino; -webkit-text-stroke: #000000}
    li.li34 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 17.0px; font: 13.0px 'Songti SC'}
    span.s1 {font: 13.0px 'Songti SC'}
    span.s2 {font: 18.0px Palatino}
    span.s3 {font: 12.0px 'PingFang SC'; font-kerning: none; background-color: #d9d7ff}
    span.s4 {font: 13.0px Palatino}
    span.s5 {font: 11.0px 'PingFang SC'}
    span.s6 {color: #fb0017}
    span.s7 {font: 13.0px Palatino; color: #fb0017}
    span.s8 {font: 11.0px Menlo}
    span.s9 {color: #000000}
    span.s10 {font: 13.0px Palatino; color: #000000}
    span.s11 {font: 11.0px Menlo; color: #fb0017}
    span.s12 {text-decoration: underline ; color: #fb0017}
    span.s13 {color: #1080d6}
    span.s14 {font: 11.0px Menlo; color: #1080d6}
    span.s15 {font: 11.0px Menlo; -webkit-text-stroke: 0px #000000}
    span.s16 {-webkit-text-stroke: 0px #000000}
    span.s17 {font: 13.0px Palatino; -webkit-text-stroke: 0px #000000}
    span.s18 {font: 12.0px Courier; font-kerning: none; color: #000000}
    span.s19 {font: 12.0px 'PingFang SC'; font-kerning: none; color: #000000}
    span.s20 {font: 13.0px 'Songti SC'; -webkit-text-stroke: 0px #000000}
    span.s21 {font: 12.0px 'PingFang SC'; font-kerning: none; color: #fb0017; background-color: #d9d7ff}
    span.Apple-tab-span {white-space:pre}
    table.t1 {border-collapse: collapse}
    td.td1 {width: 110.0px; border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #000000 #000000 #000000 #000000; padding: 0.0px 5.0px 0.0px 5.0px}
    td.td2 {width: 237.0px; border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #000000 #000000 #000000 #000000; padding: 0.0px 5.0px 0.0px 5.0px}
    ol.ol1 {list-style-type: decimal}
    ol.ol2 {list-style-type: lower-roman}
    ul.ul1 {list-style-type: hyphen}
    ul.ul2 {list-style-type: disc}
  </style>


<p class="p1"><b>【实验一于2019年4月3日开始做，环境配置及 Exercises，于4月6日完成，初稿报告4月7日】</b></p>
<p class="p2">实验分为三个部分：</p>
<ol class="ol1">
  <li class="li3">bootstrap <span class="s1">执行流程，熟悉</span> x86 <span class="s1">汇编，</span>QEMU x86 <span class="s1">模拟器，</span>PC's power</li>
  <li class="li3">lab/boot <span class="s1">目录，</span>bootloader</li>
  <li class="li3">lab/kernel <span class="s1">目录，</span>JOS <span class="s1">内核初始化模块</span></li>
</ol>
<h1 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 24.0px 'Songti SC'; -webkit-text-stroke: #000000"><b>Part 1: PC Bootstrap</b></h1>
<p class="p5"><span class="s3"><b>Exercise 1. 熟悉内联汇编</b></span></p>
<p class="p6"><span class="s1">阅读</span> <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan's Guide to Inline Assembly</a><span class="s1">，</span>JOS <span class="s1">里面会使用</span> AT&amp;T <span class="s1">语法</span></p>
<p class="p7">另外还有更详细的参考资料：</p>
<ul class="ul1">
  <li class="li8"><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Programmer's Reference Manual</a> <span class="s1">包含在</span> 6.828 <span class="s1">中将要使用到的所有处理器特性的介绍</span></li>
  <li class="li8"><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">IA-32 Intel Architecture Software Developer's Manuals</a></li>
  <li class="li8"><a href="https://developer.amd.com/resources/developer-guides-manuals/">AMD64 Architecture Programmer's Manual</a></li>
  <li class="li8"><span class="s1">推荐阅读</span><a href="https://www.linuxprobe.com/gcc-how-to.html"><span class="s1">最牛</span> X <span class="s1">的</span> GCC <span class="s1">内联汇编</span></a>，<span class="s1">查看更完整的内容，整理的内容足够阅读内联汇编代码</span></li>
</ul>
<p class="p9"><b>【准备工作】为了进行下面的实验，需要进行一些配置：</b></p>
<ol class="ol1">
  <li class="li8"><span class="s1">按照</span> <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">Tools Used in 6.828</a> <span class="s1">进行配置，对</span> macOS <span class="s1">需要按照网页说明安装定制化的</span> QEMU <span class="s1">模拟器</span><span class="Apple-converted-space"> </span>
  <ul class="ul1">
    <li class="li10"><span class="s4"></span><span class="s1">安装</span><span class="s4"> QEMU </span><span class="s1">的依赖文件，</span>brew install $(brew deps qemu)</li>
    <li class="li10"><span class="s4"></span><span class="s1">安装定制的</span><span class="s4"> QEMU</span><span class="s1">，假设安装在用户主目录下的</span><span class="s4"> ~/opt/ </span><span class="s1">下，即</span><span class="s4"> </span>./configure<span class="s4"> </span><span class="s1">时指定</span><span class="s4"> </span>--prefix=/Users/xxxx/opt</li>
    <li class="li10"><span class="s4">Install </span><span class="s1">步骤</span><span class="s4"> </span>PATH=${PATH}:/usr/local/opt/gettext/bin make install</li>
  </ul></li>
  <li class="li8"><span class="s1">使用</span> brew <span class="s1">安装</span> i386-elf-binutils/i386-elf-gcc/i386-elf-gdb</li>
  <li class="li9"><span class="s4"></span>不修改各个实验的<span class="s4"> Makefile</span>，转而修改用户主目录（<span class="s4">~</span>）下的<span class="s4"> .zshenv (</span>或者对应的<span class="s4"> .bashrc)</span>，这是对当前用户环境变量的全局修改
  <ul class="ul1">
    <li class="li10"><span class="s4"></span><span class="s1">找到</span><span class="s4"> QEMU </span><span class="s1">可执行文件，</span>export PATH="/Users/xxxx/opt/bin:$PATH"</li>
    <li class="li10"><span class="s4"></span><span class="s1">添加</span><span class="s4"> GCCPREFIX</span><span class="s1">，</span>export GCCPREFIX="i386-elf-"</li>
    <li class="li10"><span class="s4"></span><span class="s1">添加</span><span class="s4"> gdb </span><span class="s1">同名，</span>alias gdb="i386-elf-gdb"</li>
  </ul></li>
</ol>
<p class="p5"><span class="s3"><b>Exercise 2. 使用 GDB 进行调试，跟踪 ROM BIOS 指令的执行</b></span></p>
<ol class="ol1">
  <li class="li8"><span class="s1">打开两个终端，</span>cd ~/6.828/lab<span class="s1">，处于相同的目录</span></li>
  <li class="li8"><span class="s1">一个终端启动</span> QEMU <span class="s1">模拟器的</span> GDB <span class="s1">模式执行 </span><b>make qemu-nox-gdb</b><span class="s1">，</span>QEMU <span class="s1">在第一条指令之前暂停，等待</span> GDB <span class="s1">的连接</span></li>
  <li class="li8"><span class="s1">另一个终端执行</span> <b>gdb </b><span class="s1">（不是如</span> Lab 1 <span class="s1">网页说明执行</span> <b>make gdb</b><span class="s1">，需要注意）</span></li>
</ol>
<p class="p7">最开始是一条跳转指令，跳转到 <span class="s4">0xfe05b</span> 进行执行：</p>
<p class="p11"><br></p>
<p class="p12">[<b>f000:fff0</b>]<span class="Apple-converted-space">    </span><b>0xffff0</b>:<span class="Apple-converted-space">  </span><b>ljmp</b> <span class="Apple-converted-space">  </span>$0xf000,$0xe05b<span class="Apple-converted-space">  </span># <span class="s5">跳转指令</span></p>
<p class="p11"><br></p>
<p class="p7">使用<span class="s4"> <b>si</b> </span>单步执行</p>
<p class="p11"><br></p>
<p class="p12">[f000:d15f]<span class="Apple-converted-space">    </span>0xfd15f: <span class="Apple-converted-space">  </span>cli<span class="Apple-converted-space">                    </span># <span class="s5">关闭中断</span></p>
<p class="p12">[f000:d171]<span class="Apple-converted-space">    </span>0xfd171: <span class="Apple-converted-space">  </span>lidtw<span class="Apple-converted-space">  </span>%cs:0x6ab8</p>
<p class="p12">[f000:d177]<span class="Apple-converted-space">    </span>0xfd177: <span class="Apple-converted-space">  </span>lgdtw<span class="Apple-converted-space">  </span>%cs:0x6a74<span class="Apple-converted-space">      </span>#<span class="Apple-converted-space"> </span></p>
<p class="p12">[f000:d17d]<span class="Apple-converted-space">    </span>0xfd17d: <span class="Apple-converted-space">  </span>mov<span class="Apple-converted-space">    </span>%cr0,%eax</p>
<p class="p12">[f000:d180]<span class="Apple-converted-space">    </span>0xfd180: <span class="Apple-converted-space">  </span>or <span class="Apple-converted-space">    </span>$0x1,%eax</p>
<p class="p12">[f000:d184]<span class="Apple-converted-space">    </span>0xfd184: <span class="Apple-converted-space">  </span>mov<span class="Apple-converted-space">    </span>%eax,%cr0 <span class="Apple-converted-space">      </span># cr0 <span class="s5">最低位置</span> 0</p>
<p class="p11"><br></p>
<p class="p7"><span class="s4">BIOS </span>建立中断描述符表和初始化一系列硬件设备，进行一些检验工作，之后搜索可启动的设备，<span class="s6"><b>加载该存储设备上的第一个扇区的</b></span><span class="s7"><b> 512 </b></span><span class="s6"><b>字节到内存的</b></span><span class="s7"><b> 0x7C00</b></span><b>（这是 BIOS 固件完成的）</b>，然后跳转到<span class="s4"> @0x7C00 </span>的第一条指令开始执行（<b>将控制权转移给</b><span class="s4"><b> bootloader</b></span>）</p>
<p class="p6"><span class="s1">设置断点在</span> 0x7C00<span class="s1">，</span><span class="s8"><b>b *0x7c00</b></span><span class="s1">，继续执行</span> <b>c</b>(ontinue)</p>
<p class="p11"><br></p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c00] =&gt; 0x7c00:<span class="Apple-converted-space">    </span>cli</p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c01] =&gt; 0x7c01:<span class="Apple-converted-space">    </span>cld</p>
<p class="p11"><br></p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c1e] =&gt; 0x7c1e:<span class="Apple-converted-space">    </span>lgdtw<span class="Apple-converted-space">  </span>0x7c64</p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c23] =&gt; 0x7c23:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>%cr0,%eax</p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c26] =&gt; 0x7c26:<span class="Apple-converted-space">    </span>or <span class="Apple-converted-space">    </span>$0x1,%eax</p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c2a] =&gt; 0x7c2a:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>%eax,%cr0</p>
<p class="p12">[ <span class="Apple-converted-space">  </span>0:7c2d] =&gt; 0x7c2d:<span class="Apple-converted-space">    </span>ljmp <span class="Apple-converted-space">  </span>$0x8,$0x7c32</p>
<p class="p11"><br></p>
<p class="p7">执行<span class="s4"> </span><span class="s8"><b>x/Ni ADDR</b></span><span class="s4"> </span>打印从<span class="s4"> ADDR </span>地址开始的连续<span class="s4"> N </span>条汇编指令（以上关于<span class="s4"> BIOS </span>的部分不是<span class="s4"> 6.828 </span>重点关注的部分，执行时单步跟踪能够看出一点端倪，具体在<span class="s4"> lab </span>实验目录中没有源码对应）</p>
<h1 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 24.0px 'Songti SC'; -webkit-text-stroke: #000000"><b>Part 2: The Boot Loader</b></h1>
<p class="p7">源代码：<span class="s4">1</span>）汇编源文件<span class="s4"> </span><span class="s8"><b>boot/boot.S</b></span>，<span class="s4">2</span>）<span class="s4">C </span>源文件<span class="s4"> </span><span class="s8"><b>boot/main.c</b></span>。<span class="s4">bootloader </span>主要做两件事：</p>
<ol class="ol1">
  <li class="li9"><span class="s4"></span>从实模式（<span class="s4">real mode</span>）切换到保护模式（<span class="s4">32-bit protected mode</span>）。在实模式下只能寻址<span class="s4"> 1MB </span>的内存空间（<span class="s4">2^20</span>），在保护模式下能够寻址<span class="s4"> 4GB</span>（<span class="s4">2^32</span>），这样就能够访问处理器全部的物理内存空间</li>
  <li class="li9"><span class="s4"></span><b>读取内核映像到内存中固定位置，ELF 文件格式</b>（解析<span class="s4"> ELF </span>文件，将内核需要加载进入内存的段<span class="s4"> &lt;</span>有<span class="s4"> <b>LOAD</b> </span>标记的段<span class="s4">&gt; </span>加载进内存，放置在指定的加载地址）</li>
  <li class="li9"><span class="s4"></span>把控制权转移给<span class="s4"> JOS</span>，即将<span class="s4"> CS:EIP </span>的值指向操作系统内核所在内存中的起始点（<span class="s4">.text </span>段中程序开始执行时的起始地址）</li>
</ol>
<p class="p7">两个源文件代码的阅读：（主要参考 <a href="http://grid.hust.edu.cn/zyshao/Teaching_Material/OSEngineering/Chapter3.pdf">系统启动与初始化</a>）</p>
<p class="p7"><span class="s8"><b>boot/boot.S</b></span>：执行<span class="s4"> start </span>函数，进行一定的初始化，完成从实模式到保护模式的切换（CR0 最低位置 1），并调用<span class="s4"> bootmain </span>函数，具体细节参见 <span class="s4">bootloader </span>实模式切换到保护模式<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="s8"><b>boot/main.c</b></span>：<span class="s4">bootloader </span>让<span class="s4"> CPU </span>进入保护模式后，下一步的工作就是<span class="s6"><b>从硬盘上加载并运行</b></span><span class="s7"><b> OS</b></span>。考虑到实现的简单性，<span class="s4">bootloader </span>的访问硬盘都是<span class="s4"> LBA </span>模式<span class="s4"> </span>的<span class="s4"> <b>PIO</b></span>（<span class="s4">Program IO</span>）方式，即<b>所有的</b><span class="s4"><b> IO </b></span><b>操作是通过</b><span class="s4"><b> CPU </b></span><b>访问硬盘的</b><span class="s4"><b> IO </b></span><b>地址寄存器完成</b>。当前硬盘数据是储存到硬盘扇区中，一个扇区大小为<span class="s4"> <b>512</b> </span>字节。读一个扇区的流程（可参看 <span class="s4">readsect </span>函数实现，大致理解就可以）大致如下：</p>
<ol class="ol2">
  <li class="li9"><span class="s4"></span>等待磁盘准备好；</li>
  <li class="li9"><span class="s4"></span>发出读取扇区的命令；</li>
  <li class="li9"><span class="s4"></span>等待磁盘准备好；</li>
  <li class="li9"><span class="s4"></span>把磁盘扇区数据读到指定内存。</li>
</ol>
<p class="p6"><span class="s1">主要查看</span> bootmain <span class="s1">函数实现：</span></p>
<p class="p11"><br></p>
<p class="p12">#define SECTSIZE    512<span class="Apple-converted-space">                      </span>// <span class="s5">扇区大小</span> 512 <span class="s5">字节</span></p>
<p class="p12">#define ELFHDR      ((struct Elf *) 0x10000) // <span class="s5">将</span> 0x10000 <span class="s5">设置为内核起始地址</span></p>
<p class="p11"><br></p>
<p class="p12">void bootmain(void)</p>
<p class="p12">{</p>
<p class="p12">    struct Proghdr *ph, *eph;</p>
<p class="p11"><br></p>
<p class="p12">    // <span class="s5">从</span>0<span class="s5">开始读取</span> 8*512=4096byte <span class="s5">的内容到</span> ELFHDR<span class="s5">（</span>4KB<span class="s5">）</span></p>
<p class="p14"><span class="s9">    </span><b>readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);<span class="Apple-converted-space">  </span>// i</b></p>
<p class="p11"><br></p>
<p class="p12">    // is this a valid ELF?</p>
<p class="p12">    if (ELFHDR-&gt;e_magic != ELF_MAGIC)</p>
<p class="p12">        goto bad;</p>
<p class="p11"><br></p>
<p class="p12">    // load each program segment (ignores ph flags)</p>
<p class="p14"><span class="s9">    </span><b>ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);<span class="Apple-converted-space">  </span>// ii</b></p>
<p class="p14"><b>    eph = ph + ELFHDR-&gt;e_phnum;</b></p>
<p class="p12">    for (; ph &lt; eph; ph++)</p>
<p class="p12">        // p_pa is the load address of this segment (as well</p>
<p class="p12">        // as the physical address)</p>
<p class="p14"><span class="s9">        readseg(</span><b>ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset</b><span class="s9">);<span class="Apple-converted-space">  </span></span><b>// iii</b></p>
<p class="p11"><br></p>
<p class="p12">    // call the entry point from the ELF header</p>
<p class="p12">    // note: does not return!</p>
<p class="p14"><span class="s9">    </span><b>((void (*)(void)) (ELFHDR-&gt;e_entry))();<span class="Apple-converted-space">  </span>// iv</b></p>
<p class="p12">}</p>
<p class="p11"><br></p>
<p class="p7">关键的几行代码已经标注为红色，需要结合下面<span class="s4"> ELF </span>文件格式来进行理解。</p>
<ol class="ol2">
  <li class="li8"><span class="s1">将</span> ELFHDR <span class="s1">从磁盘中读取到内存指定位置，</span>0x10000<span class="s1">；</span></li>
  <li class="li8"><span class="s1">对</span> ELFHDR <span class="s1">格式进行解析，得到</span> program header table <span class="s1">的起始地址存放在</span> ph <span class="s1">中，结束地址存放在</span> eph <span class="s1">中。这里将</span> ELFHDR <span class="s1">进行转型为</span> uint8_t <span class="s1">指针，做加法这个指针变量按照</span> byte <span class="s1">的偏移来加，得到</span> program header table <span class="s1">的起始地址，并转换为</span> struct Proghdr <span class="s1">类型指针</span></li>
<p class="p11"><br></p>
<p class="p14"><b>ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</b></p>
<p class="p11"><br></p>
  <li class="li8"><span class="s1">根据每个</span> program header <span class="s1">的信息读取各个段进入内存指定位置</span>，从 <b>ph-&gt;p_offset</b> <span class="s1">开始拷贝</span> <b>ph-&gt;p_memsz</b> <span class="s1">个</span> bytes <span class="s1">到</span> <b>ph-&gt;p_pa</b></li>
<p class="p11"><br></p>
<p class="p14"><span class="s9">readseg(</span><b>ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset</b><span class="s9">);</span></p>
<p class="p11"><br></p>
  <li class="li8"><span class="s1">在将内核加载到内存中后，转移到</span><b> entry point </b><span class="s1">开始执行，即</span><b> JOS </b><span class="s1"><b>开始运行时要执行的第一条指令的地址</b></span>。<span class="s1">这里将</span> e_entry <span class="s1">转换为一个无参数无返回值的函数，并进行函数调用</span></li>
<p class="p11"><br></p>
<p class="p14"><b>((void (*)(void)) (ELFHDR-&gt;e_entry))();</b></p>
<p class="p11"><br></p>
</ol>
<p class="p5"><span class="s3"><b>Exercise 3. 使用 GDB 单步跟踪执行</b></span></p>
<p class="p7">设置断点在<span class="s4"> 0x7C00</span>，<span class="s8"><b>b *0x7c00</b></span>，另外还设置两个断点：</p>
<ol class="ol1">
  <li class="li8"><span class="s8"><b>b *0x7d56</b></span><span class="s1">，</span>bootmain <span class="s1">函数</span> for <span class="s1">循环开始处</span></li>
  <li class="li8"><span class="s8"><b>b *0x7d71</b></span><span class="s1">，</span>ELF <span class="s1">调用</span> entry point <span class="s1">处</span></li>
</ol>
<p class="p6"><span class="s1">继续执行</span> <b>c</b>(ontinue)<span class="s1">，就可以看到</span> for <span class="s1">循环处的断点</span> hit 3 <span class="s1">次（最后一次是判断 for 循环条件不成立），说明根据</span> ELF header <span class="s1">信息读入了另外</span> 2 <span class="s1">个段（</span>.text/.data<span class="s1">，可以使用</span> <b>i386-elf-objdump -x obj/kern/kernel</b> <span class="s1">命令查看到</span> Program Header<span class="s1">）。执行到达</span> 0x7d71 <span class="s1">处时，对应汇编指令为：</span></p>
<p class="p11"><br></p>
<p class="p12">0x7d71:<span class="Apple-tab-span">	</span>call <span class="Apple-converted-space">  </span>*<span class="s6"><b>0x10018</b></span></p>
<p class="p11"><br></p>
<p class="p7">但<span class="Apple-converted-space"> </span><span class="s4"> <b>si</b> </span>单步执行的真实地址为 <span class="s11"><b>0x1000c</b></span></p>
<p class="p11"><br></p>
<p class="p12">(gdb) x/10i 0x10000c</p>
<p class="p12">=&gt; <span class="s6"><b>0x10000c</b></span>:<span class="Apple-converted-space">    </span>movw <span class="Apple-converted-space">  </span>$0x1234,0x472</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x100015:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>$0x110000,%eax</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x10001a:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>%eax,%cr3</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x10001d:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>%cr0,%eax</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x100020:<span class="Apple-converted-space">    </span>or <span class="Apple-converted-space">    </span>$0x80010001,%eax</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x100025:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>%eax,%cr0</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x100028:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>$0xf010002f,%eax</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x10002d:<span class="Apple-converted-space">    </span>jmp<span class="Apple-converted-space">    </span>*%eax<span class="Apple-converted-space">               </span><span class="s6"><b> &lt;- 0xf010002f &lt;relocated&gt;</b></span></p>
<p class="p12"><span class="Apple-converted-space">   </span>0x10002f:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>$0x0,%ebp</p>
<p class="p12"><span class="Apple-converted-space">   </span>0x100034:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>$0xf0110000,%esp</p>
<p class="p11"><br></p>
<p class="p7">回答以下 4 个问题：</p>
<ul class="ul1">
  <li class="li8">At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li>
<p class="p9">使能保护模式（置<span class="s4"> CR0 </span>最低位为<span class="s4"> 1</span>）和段机制（建立好全局描述符表<span class="s4"> GDT</span>）。执行一条长跳转指令<span class="s4"> ljmp cs:eip </span>转而执行<span class="s4"> 32-bit mode</span>
  <li class="li8"><b>What</b> is the <b>last instruction</b> of the boot loader executed, and <b>what</b> is the <b>first instruction</b> of the kernel it just loaded?</li>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>call <span class="Apple-converted-space">  </span>*<b>0x10018</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span><b>0x10000c</b>: <span class="Apple-tab-span">	</span>movw <span class="Apple-converted-space">  </span>$0x1234,0x472</p>
<p class="p9">这两个地址不相同，这是为什么？因为开启了分页机制，虚拟地址与物理地址之间的映射关系已建立好</p>
  <li class="li8"><b>Where</b> is the <b>first instruction</b> of the kernel?</li>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span><b>0x10000c</b></p>
  <li class="li8">How does the boot loader decide how many <b>sectors</b> it must read in order to fetch the entire kernel from disk? <b>Where</b> does it find this information?</li>
<p class="p12"><span class="Apple-converted-space">  </span>// load each program segment (ignores ph flags)</p>
<p class="p14"><span class="s9">  </span><b>ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);<span class="Apple-converted-space">  </span>// ii</b></p>
<p class="p14"><b>  eph = ph + ELFHDR-&gt;e_phnum;</b></p>
</ul>
<p class="p5"><span class="s3"><b>Exercise 4. C 语言中的指针</b></span></p>
<p class="p7"><span class="s4">C </span>程序设计语言<span class="s4"> </span>第<span class="s4"> 5 </span>章<span class="s4"> </span>数组与指针<span class="s4"> 5.1 - 5.5</span>（待读，之前已经看过好几遍了）</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px Palatino; -webkit-text-stroke: #000000"><b>ELF 文件格式</b></h2>
<p class="p7"><span class="s4">ELF header + </span>待加载的信息（包含连续的多个段，数据段和代码段等，这些段需要被加载到内存的指定地址）。<span class="s4">bootloader </span>不会去修改数据段和代码段，只是将它们加载进内存，然后将控制权转移给这些程序进行执行</p>
<p class="p6">ELF header <span class="s1">长度固定（</span>fixed-length<span class="s1">），后跟可变长度（</span>variable-length<span class="s1">）的</span> program header<span class="s1">，列出了要加载的各个程序段（</span>program sections<span class="s1">）。</span>inc/elf.h <span class="s1">定义了</span> ELF header</p>
<p class="p11"><br></p>
<p class="p12">struct Elf {<span class="Apple-converted-space">            </span>// ELF <span class="s5">文件头</span></p>
<p class="p12">    uint32_t e_magic;   // must equal ELF_MAGIC</p>
<p class="p12">    uint8_t e_elf[12];</p>
<p class="p12">    uint16_t e_type;</p>
<p class="p12">    uint16_t e_machine;</p>
<p class="p12">    uint32_t e_version;</p>
<p class="p12">    uint32_t <span class="s6"><b>e_entry</b></span>; <span class="Apple-converted-space">  </span>// <span class="s5">程序开始执行的起始地址</span></p>
<p class="p12">    uint32_t <span class="s6"><b>e_phoff</b></span>; <span class="Apple-converted-space">  </span>// program header table <span class="s5">的起始位置</span></p>
<p class="p12">    uint32_t e_shoff; <span class="Apple-converted-space">  </span>// section header <span class="s5">的起始位置</span></p>
<p class="p12">    uint32_t e_flags;</p>
<p class="p12">    uint16_t e_ehsize;<span class="Apple-converted-space">  </span>// ELF <span class="s5">文件本身的大小</span></p>
<p class="p12">    uint16_t e_phentsize;</p>
<p class="p12">    uint16_t <span class="s6"><b>e_phnum</b></span>; <span class="Apple-converted-space">  </span>// program header <span class="s5">的个数</span></p>
<p class="p12">    uint16_t e_shentsize;</p>
<p class="p12">    uint16_t e_shnum;</p>
<p class="p12">    uint16_t e_shstrndx;</p>
<p class="p12">};</p>
<p class="p11"><br></p>
<p class="p12">struct Proghdr {<span class="Apple-converted-space">        </span>// program header table</p>
<p class="p12">    uint32_t p_type;</p>
<p class="p12">    uint32_t p_offset;</p>
<p class="p12">    uint32_t p_va;<span class="Apple-converted-space">      </span>// <span class="s5">虚拟地址</span></p>
<p class="p12">    uint32_t <span class="s6"><b>p_pa</b></span>;<span class="Apple-converted-space">      </span>// <span class="s5">物理地址</span></p>
<p class="p12">    uint32_t p_filesz;<span class="Apple-converted-space">  </span>// <span class="s5">段在文件中的大小</span></p>
<p class="p12">    uint32_t <span class="s6"><b>p_memsz</b></span>; <span class="Apple-converted-space">  </span>// <span class="s5">段在内存中的大小</span></p>
<p class="p12">    uint32_t p_flags; <span class="Apple-converted-space">  </span>// <span class="s5">读写执行权限</span></p>
<p class="p12">    uint32_t p_align;</p>
<p class="p12">};</p>
<p class="p11"><br></p>
<p class="p7">这里为什么需要 <span class="s8">p_filesz</span>、<span class="s11"><b>p_memsz</b></span><span class="s4"> </span>两个长度呢？在之后会介绍到，<span class="s4">.bss </span>在磁盘上没有存储空间，在内存中程序需要为其分配空间</p>
<p class="p18">bootloader <span class="s1">利用</span> ELF program header <span class="s1">来决定如何加载各</span> program sections<span class="s1">，而</span> program header <span class="s1">指定应该读取</span> ELF <span class="s1">对象的哪个部分进内存，以及应该放在哪里</span></p>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/elf-layout.png" width="215px" height="239px" alt="elf-layout"><span class="s1">（<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia</a>）</span></p>
<p class="p6"><span class="s1">在</span> 6.828 <span class="s1">实验中将用到的</span> program sections<span class="s1">：</span></p>
<ul class="ul2">
  <li class="li8"><b>.text</b><span class="s1">：代码段。程序的可执行指令</span></li>
  <li class="li8">.rodata<span class="s1">：只读数据段。例如</span> C <span class="s1">编译器产生的</span> ASCII <span class="s1">字符串常量</span></li>
  <li class="li8"><b>.data</b><span class="s1">：数据段。已初始化的全局变量和局部静态变量</span></li>
  <li class="li8">.bss<span class="s1">：为未初始化的全局变量和局部静态变量预留位置，但并没有内容，因此在文件中也不占据磁盘空间。由于未初始化的全局变量和局部静态变量默认值都是</span> 0，<span class="s1">本来它们也可以被放在</span> .data <span class="s1">段里，但是因为它们都是</span> 0，<span class="s1">为它们在</span> .data <span class="s1">段分配空间并存放数据</span> 0 <span class="s1">是没有必要的</span></li>
  <li class="li8"><b>.stab</b><span class="s1">：符号表部分，在程序报错时提供错误信息</span></li>
  <li class="li8"><b>.stabstr</b><span class="s1">：符号表字符串部分</span></li>
  <li class="li8"><span class="s8">...</span></li>
</ul>
<p class="p11"><br></p>
<p class="p12">i386-elf-objdump -h obj/kern/kernel</p>
<p class="p11"><br></p>
<p class="p12">obj/kern/kernel: <span class="Apple-converted-space">    </span>file format elf32-i386</p>
<p class="p12">Sections:</p>
<p class="p12">Idx Name<span class="Apple-converted-space">          </span>Size<span class="Apple-converted-space">      </span><span class="s6"><b>VMA</b></span> <span class="Apple-converted-space">      </span><span class="s6"><b>LMA</b></span> <span class="Apple-converted-space">      </span>File off<span class="Apple-converted-space">  </span>Algn</p>
<p class="p12"><span class="Apple-converted-space">  </span>0 <span class="s6"><b>.text</b></span> <span class="Apple-converted-space">        </span>0000171e<span class="Apple-converted-space">  </span><span class="s6">f0100000</span><span class="Apple-converted-space">  </span><span class="s6">00100000</span><span class="Apple-converted-space">  </span>00001000<span class="Apple-converted-space">  </span>2**2</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, READONLY, CODE</p>
<p class="p12"><span class="Apple-converted-space">  </span>1 .rodata <span class="Apple-converted-space">      </span>00000714<span class="Apple-converted-space">  </span>f0101720<span class="Apple-converted-space">  </span>00101720<span class="Apple-converted-space">  </span>00002720<span class="Apple-converted-space">  </span>2**5</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, READONLY, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>2 .stab <span class="Apple-converted-space">        </span>000040ed<span class="Apple-converted-space">  </span>f0101e34<span class="Apple-converted-space">  </span>00101e34<span class="Apple-converted-space">  </span>00002e34<span class="Apple-converted-space">  </span>2**2</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, READONLY, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>3 .stabstr<span class="Apple-converted-space">      </span>00001957<span class="Apple-converted-space">  </span>f0105f21<span class="Apple-converted-space">  </span>00105f21<span class="Apple-converted-space">  </span>00006f21<span class="Apple-converted-space">  </span>2**0</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, READONLY, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>4 .data <span class="Apple-converted-space">        </span>0000a300<span class="Apple-converted-space">  </span>f0108000<span class="Apple-converted-space">  </span>00108000<span class="Apple-converted-space">  </span>00009000<span class="Apple-converted-space">  </span>2**12</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>5 .bss<span class="Apple-converted-space">          </span>00000648<span class="Apple-converted-space">  </span>f0112300<span class="Apple-converted-space">  </span>00112300<span class="Apple-converted-space">  </span>00013300<span class="Apple-converted-space">  </span>2**5</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>6 .debug ......</p>
<p class="p12"><span class="Apple-converted-space">  </span>......</p>
<p class="p11"><br></p>
<p class="p7">得到<span class="s4"> ELF </span>文件各个段的基本信息，可以知道很多段都是<span class="s4"> Debug </span>信息（<span class="s4">program loader </span>不会将这些段加载进内存）</p>
<p class="p7">查看更详细的信息：</p>
<p class="p11"><br></p>
<p class="p12">i386-elf-objdump -x obj/kern/kernel</p>
<p class="p11"><br></p>
<p class="p12">obj/kern/kernel: <span class="Apple-converted-space">    </span>file format elf32-i386</p>
<p class="p12">obj/kern/kernel</p>
<p class="p12">architecture: i386, flags 0x00000112:</p>
<p class="p12">EXEC_P, HAS_SYMS, D_PAGED</p>
<p class="p12">start address <span class="s12"><b>0x0010000c</b></span></p>
<p class="p11"><br></p>
<p class="p14"><b>Program Header</b><span class="s9">:</span></p>
<p class="p12"><span class="Apple-converted-space">    </span><b>LOAD</b> off<span class="Apple-converted-space">    </span>0x00001000 vaddr <span class="s6"><b>0xf0100000</b></span> paddr <span class="s13"><b>0x00100000</b></span> align 2**12</p>
<p class="p12"><span class="Apple-converted-space">         </span>filesz 0x00007878 memsz 0x00007878 flags r-x</p>
<p class="p12"><span class="Apple-converted-space">    </span><b>LOAD</b> off<span class="Apple-converted-space">    </span>0x00009000 vaddr <span class="s6"><b>0xf0108000</b></span> paddr <span class="s13"><b>0x00108000</b></span> align 2**12</p>
<p class="p12"><span class="Apple-converted-space">         </span>filesz 0x0000a948 memsz 0x0000a948 flags rw-</p>
<p class="p11"><br></p>
<p class="p12">Sections:</p>
<p class="p12">Idx Name<span class="Apple-converted-space">          </span>Size<span class="Apple-converted-space">      </span>VMA <span class="Apple-converted-space">      </span>LMA <span class="Apple-converted-space">      </span>File off<span class="Apple-converted-space">  </span>Algn</p>
<p class="p12"><span class="Apple-converted-space">  </span>0 .text <span class="Apple-converted-space">        </span><b>0000171e</b><span class="Apple-converted-space">  </span><span class="s6"><b>f0100000</b></span><span class="Apple-converted-space">  </span><span class="s13"><b>00100000</b></span><span class="Apple-converted-space">  </span>00001000<span class="Apple-converted-space">  </span>2**2</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, READONLY, CODE</p>
<p class="p12"><span class="Apple-converted-space">  </span>1 .rodata <span class="Apple-converted-space">      </span>...</p>
<p class="p12"><span class="Apple-converted-space">  </span>2 .stab <span class="Apple-converted-space">        </span>...</p>
<p class="p12"><span class="Apple-converted-space">  </span>3 .stabstr<span class="Apple-converted-space">      </span>...</p>
<p class="p12"><span class="Apple-converted-space">  </span>4 .data <span class="Apple-converted-space">        </span><b>0000a300</b><span class="Apple-converted-space">  </span><span class="s6"><b>f0108000</b></span><span class="Apple-converted-space">  </span><span class="s13"><b>00108000</b></span><span class="Apple-converted-space">  </span>00009000<span class="Apple-converted-space">  </span>2**12</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>......</p>
<p class="p20"><br></p>
<p class="p7">对于内核映像，其链接地址和加载地址不同，内核希望<span class="s4"> bootloader </span>将其加载到低物理地址处（<span class="s14"><b>0x00100000</b></span> 最下面的<span class="s4"> 1MB </span>处），但是期望在高地址（虚拟地址）出进行执行（<span class="s11"><b>0xf0100000</b></span>）。这里带标识 <span class="s8"><b>LOAD</b></span> 的 <span class="s4">Program Header </span>段（可能一个段包含多个<span class="s4"> Sections</span>，<span class="s4">.data/.text/etc.</span>），即多个<span class="s4"> Sections </span>被同时加载进入内存</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px Palatino; -webkit-text-stroke: #000000"><b>链接地址和加载地址（link address and load address）</b></h2>
<p class="p7">我们关注<span class="s4"> .text </span>段的<span class="s4"> VMA(or link address</span>，虚拟地址<span class="s4">) </span>和<span class="s4"> LMA(or load address</span>，物理地址<span class="s4">)</span>。段的<span class="s4"> LMA (load address)</span>指定了将这个段加载进内存时需要放置的物理地址。段的<span class="s4"> VMA (link address)</span>指定了程序执行时这个段需要放置在内存中的虚拟地址。为了保证程序能够正常的执行，需要进行链接。</p>
<p class="p7"><b>链接地址实际上就是程序自己假设在内存中存放的地址，即编译器在编译的时候会认定程序将会连续的存放在从起始处的链接地址开始的内存空间</b>。而<b>加载地址这是可执行程序在物理内存中真正存放的位置</b>，在<span class="s4"> JOS </span>中，<span class="s4">bootloader </span>是被<span class="s4"> BIOS </span>装载到内存的，由于 <b>BIOS 实际上规定 bootloader 要被存放在物理内存的 0x7c00 处</b>，于是不论程序的链接地址怎么改变，它装载在内存中的位置（加载地址）都不会变化。</p>
<p class="p21"><b>链接地址是指令运行时的地址，加载地址是指令加载到内存中的地址。实模式下这两个地址是一样的，因为没有开启分页机制，指令执行的时候就没有地址映射关系</b></p>
<p class="p7">我们可以看到<span class="s4"> bootloader </span>的链接地址和加载地址是相等的，为<span class="s4"> 0x7c00</span></p>
<p class="p11"><br></p>
<p class="p12">i386-elf-objdump -h obj/boot/boot.out</p>
<p class="p11"><br></p>
<p class="p12">obj/boot/boot.out: <span class="Apple-converted-space">    </span>file format elf32-i386</p>
<p class="p12">Sections:</p>
<p class="p12">Idx Name<span class="Apple-converted-space">          </span>Size<span class="Apple-converted-space">      </span><span class="s6"><b>VMA</b></span> <span class="Apple-converted-space">      </span><span class="s6"><b>LMA</b></span> <span class="Apple-converted-space">      </span>File off<span class="Apple-converted-space">  </span>Algn</p>
<p class="p12"><span class="Apple-converted-space">  </span>0 <span class="s6"><b>.text</b></span> <span class="Apple-converted-space">        </span>0000018c<span class="Apple-converted-space">  </span><span class="s6"><b>00007c00</b></span><span class="Apple-converted-space">  </span><span class="s6"><b>00007c00</b></span><span class="Apple-converted-space">  </span>00000054<span class="Apple-converted-space">  </span>2**2</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, CODE</p>
<p class="p12"><span class="Apple-converted-space">  </span>1 .eh_frame <span class="Apple-converted-space">    </span>0000009c<span class="Apple-converted-space">  </span>00007d8c<span class="Apple-converted-space">  </span>00007d8c<span class="Apple-converted-space">  </span>000001e0<span class="Apple-converted-space">  </span>2**2</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, ALLOC, LOAD, READONLY, DATA</p>
<p class="p12"><span class="Apple-converted-space">  </span>2 .stab <span class="Apple-converted-space">        </span>00000744<span class="Apple-converted-space">  </span>00000000<span class="Apple-converted-space">  </span>00000000<span class="Apple-converted-space">  </span>0000027c<span class="Apple-converted-space">  </span>2**2</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, READONLY, DEBUGGING</p>
<p class="p12"><span class="Apple-converted-space">  </span>3 .stabstr<span class="Apple-converted-space">      </span>000008e1<span class="Apple-converted-space">  </span>00000000<span class="Apple-converted-space">  </span>00000000<span class="Apple-converted-space">  </span>000009c0<span class="Apple-converted-space">  </span>2**0</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, READONLY, DEBUGGING</p>
<p class="p12"><span class="Apple-converted-space">  </span>4 .comment<span class="Apple-converted-space">      </span>00000011<span class="Apple-converted-space">  </span>00000000<span class="Apple-converted-space">  </span>00000000<span class="Apple-converted-space">  </span>000012a1<span class="Apple-converted-space">  </span>2**0</p>
<p class="p12"><span class="Apple-converted-space">                  </span>CONTENTS, READONLY</p>
<p class="p11"><br></p>
<p class="p5"><span class="s3"><b>Exercise 5. 修改 boot/Makefrag，将 bootloader 的 link address 改为非 0x7c00 的数值，看看会出现什么问题</b></span></p>
<p class="p6"><span class="s1">在</span> boot/Makefrag <span class="s1">中指定了</span> bootloader <span class="s1">的链接地址</span> -Ttext 0x7C00<span class="s1">，现在我们将链接地址修改为</span> 0x8C00<span class="s1">，重新编译</span></p>
<ol class="ol1">
  <li class="li8"><span class="s1">设置断点</span> <span class="s8"><b>b *0x7c00</b></span><span class="s1">，</span>BIOS <span class="s1">一定会将</span> bootloader <span class="s1">加载到这个位置</span></li>
  <li class="li8"><span class="s4"><b>si</b> </span><span class="s1">单步跟踪执行，执行到</span><span class="s4"> </span>0x7c2d: ljmp $0x8,$<b>0x8c32</b><span class="s4"> </span><span class="s1">指令时发生错误</span></li>
  <li class="li8"><span class="s1">查看编译同时生成的反汇编文件</span> obj/boot/boot.asm，<span class="s1">其中显示了汇编指令和相应的链接地址，由于我们修改了</span> bootloader <span class="s1">的链接地址为</span> 0x8c00，“ljmp <span class="Apple-converted-space">  </span>$0x8,$0x8c32” <span class="s1">这条指令在</span> boot.asm <span class="s1">文件中显示的实际汇编地址为</span> 0x8c2d，<span class="s1">其后的</span> <b>protcseg</b> <span class="s1">标识的指令的链接地址为</span> <b>0x8c32</b><span class="s1">，即 </span><b>si</b> <span class="s1">单步执行到</span> 0x8c2d <span class="s1">处需要跳转到的标识符地址</span></li>
  <li class="li8">CPU <span class="s1">报错？为什么会报错呢？链接是怎么做的？</span></li>
</ol>
<p class="p2"><span class="s4">VMA/LMA </span>是给加载器做参考，告诉加载器<span class="s4">“</span>需要将某个段加载到某某地址<span class="s4">”</span>，但现在连操作系统都还没有运行起来，更不会有加载器。因此，<span class="s4">bootloader </span>的源代码还是会被加载到内存的<span class="s4"> 0x7c00 </span>处（因为<span class="s4"> BIOS </span>在<span class="s4"> ROM</span>，里面的程序代码是在出厂时就已经规定好了的，将磁盘的第一个扇区加载到内存的<span class="s4"> 0x7c00 </span>处）。链接最重要的一步是符号重定位（<span class="s4">symbol relocation</span>），在源代码<span class="s4"> </span><span class="s15"><b>boot/boot.S</b></span><span class="s4"> </span>中：</p>
<p class="p22"><br></p>
<p class="p23"><span class="Apple-converted-space">  </span># Jump to next instruction, but in 32-bit code segment.</p>
<p class="p23"><span class="Apple-converted-space">  </span># Switches processor into 32-bit mode.</p>
<p class="p23"><span class="Apple-converted-space">  </span>ljmp<span class="Apple-converted-space">    </span>$PROT_MODE_CSEG, $<b>protcseg</b></p>
<p class="p23"><span class="Apple-converted-space">  </span>.code32 <span class="Apple-converted-space">                    </span># Assemble for 32-bit mode</p>
<p class="p23"><b>protcseg</b>:</p>
<p class="p23"><span class="Apple-converted-space">  </span># Set up the protected-mode data segment registers</p>
<p class="p22"><br></p>
<p class="p2">这里的 <span class="s8"><b>protcseg</b></span><span class="s4"> </span>符号（<span class="s4">symbol</span>）用来标记位置，可以是一段子程序的起始地址，也可以是一个变量的起始地址。在这里 <span class="s8"><b>protcseg </b></span>表示一段程序的起始地址，在编译生成可重定位目标文件（<span class="s4">relocatable object file</span>）时其值是不确定的。在链接时，链接器会对这些符号进行替换（因为程序已经链接好了）</p>
<p class="p2">现在的问题是，链接器按照<span class="s4"> 0x8C00 </span>的链接起始地址对这些符号进行替换，但<span class="s4"> BIOS </span>还是将<span class="s4"> bootloader </span>读到了内存中的<span class="s4"> 0x7C00 </span>处，实模式下（仅开启了段机制），加载地址和链接地址应该是相同的。而现在，<span class="s4">ljmp </span>指令要跳转到 <span class="s11"><b>0x8c32 </b></span>处，本来应该跳转到下一条指令 <span class="s8"><b>0x7c32 </b></span>处【TODO 需要更加细致的分析！】</p>
<p class="p22"><br></p>
<p class="p23">(gdb) x/10i 0x7c1e</p>
<p class="p24"><span class="s9"><span class="Apple-converted-space">   </span></span><b>0x7c1e:<span class="Apple-tab-span">	</span>lgdtw<span class="Apple-converted-space">  </span>-0x739c</b></p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c23:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>%cr0,%eax</p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c26:<span class="Apple-tab-span">	</span>or <span class="Apple-converted-space">    </span>$0x1,%eax</p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c2a:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>%eax,%cr0</p>
<p class="p24"><span class="s9">=&gt; </span><b>0x7c2d:<span class="Apple-tab-span">	</span>ljmp <span class="Apple-converted-space">  </span>$0x8,$0x8c32</b></p>
<p class="p23"><span class="Apple-converted-space">   </span><b>0x7c32</b>:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>$0xd88e0010,%eax</p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c38:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>%ax,%es</p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c3a:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>%ax,%fs</p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c3c:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>%ax,%gs</p>
<p class="p23"><span class="Apple-converted-space">   </span>0x7c3e:<span class="Apple-tab-span">	</span>mov<span class="Apple-converted-space">    </span>%ax,%ss</p>
<p class="p22"><br></p>
<p class="p5"><span class="s3"><b>Exercise 6. 执行 x/Nx ADDR 打印从 ADDR 出的 N 个 word（在 GNU 汇编标准中，1 word = 2 bytes）。在两个不同的时刻检查 0x00100000 出的 8 个 word，1）BIOS 将控制权转移给 bootloader 和 2）bootloader 将 JOS 内核映像读入内存之后，将控制权转移给 JOS（entry point），有什么不一样，并且为什么这 8 个 word 会不一样？</b></span></p>
<ol class="ol1">
  <li class="li25">关闭 QEMU 和 GDB，重新运行；</li>
  <li class="li26"><span class="s1">设置断点</span> <span class="s8"><b>b *0x7c00</b></span><span class="s1">（</span>BIOS <span class="s1">将控制权转移给</span> bootloader<span class="s1">）和</span> <span class="s8"><b>b *0x7d71</b></span><span class="s1">（</span>bootloader <span class="s1">将控制权转移给</span> JOS<span class="s1">）</span></li>
</ol>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/ex-6.png" width="338px" height="282px" alt="ex-6"></p>
<p class="p7">前后两次执行<span class="s4"> </span><span class="s8"><b>x/Nx ADDR</b></span><span class="s4"> </span>结果不一样，第二次是因为我们使用 bootloader 将将<span class="s4"> JOS </span>的程序段（<span class="s4">Program Header </span>中有<span class="s4"> <b>LOAD</b> </span>标记的段）加载到了<span class="s4"> 0x100000 </span>处，因此，从<span class="s4"> 0x100000 </span>开始都存放着<span class="s4"><b> JOS </b></span><b>内核映像</b></p>
<h1 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 24.0px 'Songti SC'; -webkit-text-stroke: #000000"><b>Part 3：The Kernel</b></h1>
<p class="p2">操作系统内核一般链接地址都比较大，会选择在高虚拟地址空间上运行，将低虚拟地址空间留给用户程序使用（在<span class="s4"> Lab2 </span>中会进行更清晰的解释）</p>
<p class="p7">很多机器的物理内存空间地址都不会到达 <span class="s11"><b>0xf010002f</b></span>，因此<span class="s4"> JOS </span>内核映像不会真实存储于此，而是，我们使用处理器的内存管理硬件（<span class="s4">memory management hardware</span>）将高虚拟地址空间 <span class="s11"><b>0xf0100000</b></span>（内核的链接地址，期望运行的虚拟地址）映射到实际的低物理地址空间 <span class="s11"><b>0x00100000</b></span>（内核的加载地址，<span class="s4">bootloader </span>将内核映像加载进内存中的地址），<span class="s4">bootloader </span>加载磁盘上的内核映像存放在内存中的地址为 <span class="s11"><b>0x00100000</b></span>（刚好在<span class="s4"> BIOS ROM </span>的上面，从<span class="s4"> 1MB </span>地址往上），<span class="s16">可以查看命令</span><span class="s17"> <b>i386-elf-objdump -x obj/kern/kernel</b> </span><span class="s16">的返回内容</span></p>
<p class="p7"><span class="s4">kern/entrypgdir.c </span>中已经建立好了虚拟地址和物理地址的映射关系 <span class="s18">entry_pgdir</span>：</p>
<ul class="ul2">
  <li class="li8">Map VA's [0, 4MB) to PA's [0, 4MB)</li>
  <li class="li8">Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB) <span class="s1">其中，</span>KERNBASE=0xF0000000</li>
</ul>
<p class="p7">在 <span class="s18">kern/entry.S </span>中会对 <span class="s18">CR0_PG</span><span class="s19"> flag</span> 进行设置，在此设置之前，代码中对内存的引用（<span class="s4">memory references</span>）都会被解释为物理地址（更准确的说是线性地址，在<span class="s4"> boot/boot.S </span>中仅开启段机制，线性地址与物理地址相等），当对 <span class="s18">CR0_PG</span> 设置之后，对内存的引用将被解释为虚拟地址（即开启页机制），再由 <span class="s18">entry_pgdir </span>翻译为对应的物理地址</p>
<ul class="ul2">
  <li class="li10"><span class="s4"></span><span class="s1">将</span><span class="s4"> </span>0xf0000000<span class="s4"> ~ </span>0xf0400000<span class="s4"> </span><span class="s1">虚拟地址翻译为对应的物理地址</span><span class="s4"> </span>0x00000000<span class="s4"> ~ </span>0x00400000</li>
  <li class="li10"><span class="s4"></span><span class="s1">将</span><span class="s4"> </span>0x00000000<span class="s4"> ~ </span>0x00400000<span class="s4"> </span><span class="s1">虚拟地址翻译为对应的物理地址</span><span class="s4"> </span>0x00000000<span class="s4"> ~ </span>0x00400000</li>
</ul>
<p class="p1"><span class="s16">在内核被加载到内存后系统便立</span>即跳转开始执行<span class="s4"> kern/entry.S </span>的代码，这个文件中的程序相当于内核的入口程序</p>
<p class="p11"><br></p>
<p class="p12">.globl      _start</p>
<p class="p12">_start = <span class="s6"><b>RELOC</b></span>(entry)</p>
<p class="p11"><br></p>
<p class="p12">.globl entry</p>
<p class="p12">entry:</p>
<p class="p12">    movw    $0x1234,0x472           # warm boot</p>
<p class="p11"><br></p>
<p class="p12">    # We haven't set up virtual memory yet, so we're running from</p>
<p class="p12">    # the physical address the boot loader loaded the kernel at: 1MB</p>
<p class="p12">    # (plus a few bytes).<span class="Apple-converted-space">  </span>However, the C code is linked to run at</p>
<p class="p12">    # KERNBASE+1MB.<span class="Apple-converted-space">  </span>Hence, we set up a trivial page directory that</p>
<p class="p12">    # translates virtual addresses [KERNBASE, KERNBASE+4MB) to</p>
<p class="p12">    # physical addresses [0, 4MB).<span class="Apple-converted-space">  </span>This 4MB region will be</p>
<p class="p12">    # sufficient until we set up our real page table in mem_init</p>
<p class="p12">    # in lab 2.</p>
<p class="p11"><br></p>
<p class="p12">    # Load the physical address of entry_pgdir into cr3.<span class="Apple-converted-space">  </span>entry_pgdir</p>
<p class="p12">    # is defined in entrypgdir.c.</p>
<p class="p14"><span class="s9">    </span><b>movl    $(RELOC(entry_pgdir)), %eax</b></p>
<p class="p14"><b>    movl    %eax, %cr3</b></p>
<p class="p12">    # Turn on paging.</p>
<p class="p12">    movl    %cr0, %eax</p>
<p class="p12">    orl $(CR0_PE|<span class="s6"><b>CR0_PG</b></span>|CR0_WP), %eax</p>
<p class="p12">    movl    %eax, %cr0</p>
<p class="p11"><br></p>
<p class="p12">    # Now paging is enabled, but we're still running at a low EIP</p>
<p class="p12">    # (why is this okay?).<span class="Apple-converted-space">  </span>Jump up above KERNBASE before entering</p>
<p class="p12">    # C code.</p>
<p class="p12">    mov $<span class="s6"><b>relocated</b></span>, %eax<span class="Apple-converted-space">  </span># $relocated <span class="s5">为链接地址，因此需要重定位</span></p>
<p class="p12">    jmp *%eax</p>
<p class="p14"><b>relocated</b><span class="s9">:</span></p>
<p class="p11"><br></p>
<p class="p12">    # Clear the frame pointer register (EBP)</p>
<p class="p12">    # so that once we get into debugging C code,</p>
<p class="p12">    # stack backtraces will be terminated properly.</p>
<p class="p12">    movl    $0x0,%ebp           # nuke frame pointer</p>
<p class="p11"><br></p>
<p class="p12">    # Set the stack pointer</p>
<p class="p12">    movl    $(bootstacktop),%esp</p>
<p class="p11"><br></p>
<p class="p12">    # now to C code</p>
<p class="p12">    call    i386_init</p>
<p class="p11"><br></p>
<p class="p5"><span class="s3"><b>Exercise 7. 使用 QEMU 和 GDB 单步跟踪 JOS，执行到 movl %eax, %cr0，检查在执行这条汇编指令前后内存单元 0x00100000 和 0xf0100000 的内容</b> </span></p>
<ol class="ol1">
  <li class="li25">设置断点<span class="s4"> </span><span class="s8"><b>b *0x7d71</b></span>（<span class="s4">bootloader </span>将控制权转移给<span class="s4"> JOS</span>）</li>
  <li class="li25"><span class="s4"><b>si</b> </span>单步跟踪执行</li>
</ol>
<p class="p12">=&gt; 0x100025:<span class="Apple-converted-space">    </span><span class="s6"><b>mov<span class="Apple-converted-space">    </span>%eax,%cr0</b></span></p>
<p class="p12">(gdb) x/8x 0x00100000</p>
<p class="p12">0x100000:<span class="Apple-tab-span">	</span> <span class="Apple-converted-space">                    </span>0x1badb002 0x00000000 0xe4524ffe 0x7205c766</p>
<p class="p12">0x100010:<span class="Apple-tab-span">	</span> <span class="Apple-converted-space">                    </span>0x34000004 0x0000b812 0x220f0011 0xc0200fd8</p>
<p class="p12">(gdb) x/8x 0xf0100000</p>
<p class="p12">0xf0100000 &lt;_start+4026531828&gt;: 0x00000000 0x00000000 0x00000000 0x00000000</p>
<p class="p12">0xf0100010 &lt;entry+4&gt;: <span class="Apple-converted-space">          </span>0x00000000 0x00000000 0x00000000 0x00000000</p>
<p class="p12">(gdb) si</p>
<p class="p12">=&gt; 0x100028:<span class="Apple-converted-space">    </span>mov<span class="Apple-converted-space">    </span>$0xf010002f,%eax</p>
<p class="p12">(gdb) x/8x 0x00100000</p>
<p class="p12">0x100000:<span class="Apple-tab-span">	</span> <span class="Apple-converted-space">                    </span>0x1badb002 0x00000000 0xe4524ffe 0x7205c766</p>
<p class="p12">0x100010:<span class="Apple-tab-span">	</span> <span class="Apple-converted-space">                    </span>0x34000004 0x0000b812 0x220f0011 0xc0200fd8</p>
<p class="p12">(gdb) x/8x 0xf0100000</p>
<p class="p12">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766</p>
<p class="p12">0xf0100010 &lt;entry+4&gt;: <span class="Apple-converted-space">          </span>0x34000004 0x0000b812 0x220f0011 0xc0200fd8</p>
<p class="p11"><br></p>
<p class="p6"><span class="s1"><b>执行</b></span><b> </b><span class="s8"><b>mov %eax, %cr0</b></span><b> </b><span class="s1"><b>之后，建立好了虚拟地址和物理地址的映射关系</b>。如果将这条指令给注释掉，重新编译执行，同样设置断点，在</span> <span class="s8">0xf010002c &lt;relocated&gt;: add %al,(%eax)</span> <span class="s1">处</span> QEMU <span class="s1">出错退出，出错信息为：</span>“qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c”</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px 'Songti SC'; -webkit-text-stroke: #000000"><b>cprintf 函数的实现（C 语言中常用的 printf 函数）</b></h2>
<p class="p7">三个源文件代码的阅读：【TODO 分析并实现 printf 函数，包括实现浮点数打印】</p>
<p class="p7"><span class="s8"><b>kern/printf.c</b></span>：封装格式化输出函数，<span class="s16">提供</span><span class="s17"> cprintf </span><span class="s16">函数接口</span></p>
<p class="p7"><span class="s8"><b>lib/printfmt.c</b></span>：格式化字符串输出，<span class="s6"><b>需好好学习这个源码文件</b></span></p>
<p class="p28"><span class="s15"><b>kern/console.c</b></span><span class="s20">：</span><span class="s1">实现基本的</span> I/O <span class="s1">操作，提供</span> cputchar/getchar <span class="s1">供</span> readline/cprinf <span class="s1">使用</span></p>
<p class="p5"><span class="s3"><b>Exercise 8. 填充代码，支持使用 "%o" 打印八进制数（这个很简单，模仿着写，但需理解）</b></span></p>
<p class="p11"><br></p>
<p class="p12"><span class="Apple-converted-space">        </span>// (unsigned) octal</p>
<p class="p12">        case 'o':</p>
<p class="p12">            num = getuint(&amp;ap, lflag);</p>
<p class="p12">            base = 8;</p>
<p class="p12">            goto number;</p>
<p class="p11"><br></p>
<p class="p6"><span class="s1">在</span> kern/init.c i386_init() <span class="s1">函数中添加测试代码</span></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px 'Songti SC'; -webkit-text-stroke: #000000"><b>栈</b></h2>
<p class="p7">几条与栈相关的汇编指令解释</p>
<table width="100%" cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="top" class="td1">
        <p class="p6"><span class="s6"><b>pushl</b></span> %eax</p>
      </td>
      <td valign="top" class="td2">
        <p class="p6">subl $4, %esp; movl %eax, (%esp)</p>
      </td>
    </tr>
    <tr>
      <td valign="top" class="td1">
        <p class="p6"><span class="s6"><b>popl</b></span> %eax</p>
      </td>
      <td valign="top" class="td2">
        <p class="p6">movl (%esp), %eax; addl $4, %esp</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p6">call 0x1234</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p6">pushl %eip; movl 0x1234, %eip</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td1">
        <p class="p6">ret<span class="Apple-converted-space"> </span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p6">popl %eip</p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p7">（注：这里为了解释清晰，右侧指令大都不规范）</p>
<p class="p7"><span class="s6"><b>栈的生长方向是高地址到低地址</b></span>，<span class="s4">esp </span>指向栈顶（低地址），<span class="s4">ebp </span>指向栈底（高地址）</p>
<ol class="ol1">
  <li class="li9"><span class="s4"></span>当进入一个函数（<span class="s4">callee</span>）进行执行时，将调用者（<span class="s4">caller</span>）的<span class="s4"> ebp </span>压入栈</li>
  <li class="li8"><span class="s1">给</span> ebp <span class="s1">赋新值为当前</span> esp<span class="s1">（</span>ebp <span class="s1">为</span> callee <span class="s1">的栈帧栈底）</span></li>
</ol>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/my-func-enter-call.png" width="549px" height="144px" alt="my-func-enter-call"></p>
<p class="p7">现在就建立好了一个<span class="s6"><b>函数调用的链接关系</b></span>（类似链表），根据当前正在执行的函数找到<span class="s4"> ebp </span>的值，其为一个地址，该地址中存储的值为调用者的<span class="s4"> ebp</span></p>
<p class="p11"><br></p>
<p class="p12">uint32_* ebp = (uint32_t*)<span class="s6"><b>read_ebp</b></span>();<span class="Apple-converted-space">  </span>// <span class="s5">得到</span> callee <span class="s5">的</span> ebp</p>
<p class="p12">while (<b>ebp</b>) {<span class="Apple-converted-space">  </span>// <span class="s5">这里可以直接这样写，因为最初始化栈之前</span> ebp <span class="s5">的值为</span> NULL</p>
<p class="p29"><span class="s8"><span class="Apple-tab-span">	</span>......// </span>得到返回值和函数调用的参数，进行处理</p>
<p class="p12"><span class="Apple-tab-span">	</span>ebp = (uint32_t*)(<span class="s6"><b>*</b></span>ebp);<span class="Apple-converted-space">  </span>// <span class="s5">对当前</span> ebp <span class="s5">存储地址解引用就能够得到存储的</span> caller <span class="s5">的</span> ebp</p>
<p class="p12">}</p>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/stack-frame.png" width="260px" height="252px" alt="stack-frame"></p>
<p class="p30"><br></p>
<p class="p5"><span class="s3"><b>Exercise 9. 确定栈是怎么初始化的？</b></span></p>
<ol class="ol1">
  <li class="li9">设置断点 <span class="s8"><b>b *0x7d71</b></span>，<span class="s8"><b>si </b></span>单步执行，对应的源码在<span class="s4"> kern/entry.S</span></li>
  <li class="li9"><span class="s4"></span>对<span class="s4"> CR0 </span>进行设置，开启分页机制，然后执行跳转到<span class="s4"> relocated </span>标识处开始运行</li>
  <li class="li9"><span class="s4"></span><b>将</b><span class="s4"><b> ebp </b></span><b>设置为</b><span class="s4"><b> NULL</b></span>（在进行函数调用栈分析的时候使用<span class="s4"> NULL </span>作为结束标识），在<span class="s4"> .data </span>段设置的栈顶地址给<span class="s4"> esp</span>（高地址，<span class="s4">0xf0110000</span>，虚拟地址），预留了栈空间。这里定义了两个全局变量<span class="s4"> bootstack </span>和<span class="s4"> bootstacktop</span>，<span class="s4">bootstack </span>标识了内存中的一个位置，表示从这里开始的<span class="s4"> KSTKSIZE </span>个字节的区域都是属于这个临时堆栈的（<span class="s4">KSTKSIZE </span>在<span class="s4"> inc/memlayout.h </span>中定义为<span class="s4"> </span><span class="s7"><b>32K</b></span>），<span class="s4">bootstacktop </span>指向这段区域后的第一个字节，由于刚开始堆栈是空的，所以栈顶便是<span class="s4"> bootstacktop </span>所指向的位置【TODO 这里还是有点模糊】</li>
<p class="p11"><br></p>
<p class="p12">relocated:</p>
<p class="p11"><br></p>
<p class="p12">    # Clear the frame pointer register (EBP)</p>
<p class="p12">    # so that once we get into debugging C code,</p>
<p class="p12">    # stack backtraces will be terminated properly.</p>
<p class="p12">    <span class="s6"><b>movl    $0x0,%ebp</b></span>           # nuke frame pointer</p>
<p class="p11"><br></p>
<p class="p12">    # Set the stack pointer</p>
<p class="p12">    movl    $(<b>bootstacktop</b>),%esp</p>
<p class="p11"><br></p>
<p class="p12">    # now to C code</p>
<p class="p12">    call    i386_init</p>
<p class="p11"><br></p>
<p class="p12">.data</p>
<p class="p12"># boot stack</p>
<p class="p12">    .p2align    PGSHIFT     # <span class="s5">强制四字节对齐</span></p>
<p class="p12">    .globl      bootstack</p>
<p class="p12">bootstack:</p>
<p class="p12">    <b>.space</b>      KSTKSIZE</p>
<p class="p12">    .globl      bootstacktop<span class="Apple-converted-space">   </span></p>
<p class="p12"><b>bootstacktop</b>:</p>
<p class="p11"><br></p>
  <li class="li9"><span class="s4"></span>调用 <span class="s4">i386_init</span> 函数会将下一条指令的地址压入栈（<span class="s4"><b>spin</b></span>，程序不会运行到这里），同时将旧的<span class="s4"> ebp </span>压栈，<span class="s4">ebp </span>指向<span class="s4"> esp </span>的当前位置，这样就设置好了<span class="s4"> JOS </span>调用第一个<span class="s4"> C </span>函数的栈帧</li>
</ol>
<p class="p5"><span class="s3"><b>Exercise 10. 单步调试查看 backtrace 函数是怎么递归调用的？</b> </span></p>
<p class="p6">mon_backtrace <span class="s1">函数是在</span> test_backtrace <span class="s1">函数中被调用的</span></p>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/recursion.png" width="395px" height="228px" alt="recursion"></p>
<p class="p5"><span class="s3"><b>Exercise 11. mon_backtrace 功能实现（查看函数调用栈），将 backtrace 功能加入 JOS monitor 中</b> </span></p>
<p class="p7">函数参数的入栈顺序是从右到左的，即对于函数参数，最后一个参数先入栈，从右至左，第一个参数最后入栈：</p>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/func-args-push-order.png" width="352px" height="195px" alt="func-args-push-order"></p>
<p class="p7">正在执行的函数有自己的一个<span class="s4"> ebp </span>值，而这个<span class="s4"> ebp </span>作为指针（对应的那块内存）又指向调用该函数的函数的<span class="s4"> ebp </span>的值，即<span class="s4"> <b>callee </b></span><b>的</b><span class="s4"><b> ebp </b></span><b>作为指针指向</b><span class="s4"><b> caller </b></span><b>的</b><span class="s4"><b> ebp </b></span><b>值</b>。这样我们使用 ebp 不断回溯就能够打印出函数的调用栈了</p>
<p class="p11"><br></p>
<p class="p12">int <b>mon_backtrace</b>(int argc, char **argv, struct Trapframe *tf)</p>
<p class="p12">{</p>
<p class="p12">    size_t i;</p>
<p class="p12">    const size_t N = 4;</p>
<p class="p12">    uint32_t args[N];</p>
<p class="p12">    uint32_t* ebp = (uint32_t*)<span class="s6"><b>read_ebp</b></span>();</p>
<p class="p12">    while(<b>ebp</b>) { <span class="Apple-converted-space">            </span>// <span class="s5">这个循环终止条件在</span> ex9 <span class="s5">中有解释，</span><span class="s6"><b>movl $0x0,%ebp</b></span> </p>
<p class="p12">        uint32_t eip = *(ebp + 1);</p>
<p class="p12">        for (i = 0; i &lt; N; ++i)<span class="Apple-converted-space"> </span></p>
<p class="p12">            <span class="s6"><b>args[i] = *(ebp + 2 + i);</b></span><span class="Apple-converted-space">  </span>// <span class="s5">依次得到各个参数</span></p>
<p class="p12">        cprintf("ebp %08x eip %08x args", ebp, eip);</p>
<p class="p12">        for (i = 0; i &lt; N; ++i)<span class="Apple-converted-space"> </span></p>
<p class="p12">            cprintf(" %08x", args[i]);</p>
<p class="p12">        cprintf("\n");</p>
<p class="p11"><br></p>
<p class="p14"><span class="s9">        </span><b>ebp = (uint32_t*) (*ebp);</b></p>
<p class="p12">    }</p>
<p class="p11"><br></p>
<p class="p12">    return 0;</p>
<p class="p12">}</p>
<p class="p7"><span class="s4">JOS </span>启动后会出现<span class="s4">“K&gt;”</span>等待用户输入命令，已经提供了<span class="s4">“help”</span>和<span class="s4">“kerninfo”</span>两个，这里我们需要添加<span class="s4">“backtrace”</span>命令。实现原理：</p>
<p class="p11"><br></p>
<p class="p12">struct <b>Command</b> {</p>
<p class="p12">    const char *name;<span class="Apple-converted-space">  </span>// <span class="s5">命令名</span></p>
<p class="p12">    const char *desc;<span class="Apple-converted-space">  </span>// <span class="s5">命令作用，</span>help <span class="s5">时展示</span></p>
<p class="p12">    // return -1 to force monitor to exit</p>
<p class="p12">    int (*func)(int argc, char** argv, struct Trapframe* tf);</p>
<p class="p12">};</p>
<p class="p11"><br></p>
<p class="p12">static struct Command <b>commands</b>[] = {</p>
<p class="p12">    { "help", "Display this list of commands", <b>mon_help</b> },</p>
<p class="p12">    { "kerninfo", "Display information about the kernel", <b>mon_kerninfo</b> },</p>
<p class="p12">    { "backtrace", "Display stack backtrace", <b>mon_backtrace</b> },</p>
<p class="p12">};</p>
<p class="p11"><br></p>
<p class="p25">在 <span class="s4">kern/monitor.c </span>中定义一个<span class="s4"> Command </span>结构体，包含能够使用的交互命令。主要是第三个参数，表示在<span class="s4"> monitor </span>中键入命令时具体调用的处理函数。</p>
<p class="p7">当用户在<span class="s4"> monitor </span>中键入命令时是如何进行处理的呢？</p>
<ol class="ol1">
  <li class="li8">monitor <span class="s1">函数中调用</span> readline <span class="s1">读入一个命令，</span>buf <span class="s1">指向命令字符串</span></li>
<p class="p11"><br></p>
<p class="p12">    while (1) {</p>
<p class="p12">        buf = <b>readline</b>("K&gt; ");</p>
<p class="p12">        if (buf != NULL)</p>
<p class="p12">            if (<b>runcmd</b>(buf, tf) &lt; 0)</p>
<p class="p12">                break;</p>
<p class="p12">    }</p>
<p class="p11"><br></p>
  <li class="li8">runcmd <span class="s1">处理命令，接受两个参数，第一个就是命令字符串，第二个参数先不做讨论（跳过）。接下来分析</span> runcmd <span class="s1">函数的实现：<span class="s6"><b>【这个函数实现要好好学习，Redis 中也有这样的命令查表操作】</b></span></span>
</li>
</ol>
<ol class="ol2">
  <li class="li9"><span class="s4"></span>变量声明与初始化，<span class="s4">argv </span>是一个指针数组，每个数组项指向一个字符串。一个命令分为命令名<span class="s4">+</span>命令参数，因此一个命令字符串一般可以分为多个子字符串，<span class="s4">argv </span>的每个数组项指向一个子字符串。<span class="s4">argc </span>代表命令参数的个数</li>
<p class="p11"><br></p>
<p class="p12">#define WHITESPACE "\t\r\n "</p>
<p class="p11"><br></p>
<p class="p12">static int <b>runcmd</b>(char *buf, struct Trapframe *tf)</p>
<p class="p12">{</p>
<p class="p12">    int argc;</p>
<p class="p12">    char *argv[MAXARGS];</p>
<p class="p12">    int i;</p>
<p class="p11"><br></p>
<p class="p12">    // Parse the command buffer into whitespace-separated arguments</p>
<p class="p12">    argc = 0;</p>
<p class="p12">    argv[argc] = 0;</p>
<p class="p11"><br></p>
  <li class="li9"><span class="s4"></span>将<span class="s4"> argv </span>中保存每一个子字符串，并且将命令字符串中的空格都换成空字符（因为我们在输入命令是，命令名和参数之间、参数和参数之间都是使用空格间隔的），这样处理之后每个子字符串的结尾便都是一个空字符，方便处理<span class="s6"><b>【这个实现需要好好学习】</b></span></li>
<p class="p11"><br></p>
<p class="p12">    while (1) {</p>
<p class="p12">        // gobble whitespace</p>
<p class="p12">        while (*buf &amp;&amp; <b>strchr</b>(WHITESPACE, *buf))</p>
<p class="p12">            *buf++ = 0;<span class="Apple-converted-space">    </span>// <span class="s5">把所有空格字符都置为空字符</span></p>
<p class="p12">        if (*buf == 0)</p>
<p class="p12">            break; <span class="Apple-converted-space">        </span>// <span class="s5">命令结束</span></p>
<p class="p11"><br></p>
<p class="p12">        // save and scan past next arg</p>
<p class="p12">        if (argc == MAXARGS-1) {</p>
<p class="p12">            cprintf("Too many arguments (max %d)\n", MAXARGS);</p>
<p class="p12">            return 0;</p>
<p class="p12">        }</p>
<p class="p12">        argv[argc++] = buf;// <span class="s5">指向子字符串</span></p>
<p class="p12">        while (*buf &amp;&amp; !strchr(WHITESPACE, *buf))</p>
<p class="p12">            buf++; <span class="Apple-converted-space">        </span>// <span class="s5">跳过非空格的字符</span></p>
<p class="p12">    }</p>
<p class="p12">    argv[argc] = 0;</p>
<p class="p19"><img src="/post/2019-04-09-mit6.828-lab1/figures/runcmd-argv-argc.png" width="471px" height="139px" alt="runcmd-argv-argc"></p>
  <li class="li9"><span class="s4"></span>获取到<span class="s4"> argc </span>和<span class="s4"> argv </span>两个参数后，就可以开始处理命令了。在所有可以执行的命令表中查找对应的函数，调用执行</li>
<p class="p11"><br></p>
<p class="p12">    // Lookup and invoke the command</p>
<p class="p12">    if (argc == 0)<span class="Apple-converted-space">  </span>return 0;<span class="Apple-converted-space"> </span></p>
<p class="p12">    for (i = 0; i &lt; ARRAY_SIZE(commands); i++) {</p>
<p class="p12">        if (strcmp(argv[0], commands[i].name) == 0)</p>
<p class="p14"><span class="s9">            return </span><b>commands[i].func(argc, argv, tf)</b><span class="s9">;</span></p>
<p class="p12">    }</p>
<p class="p12">    cprintf("Unknown command '%s'\n", argv[0]);</p>
<p class="p12">    return 0;</p>
<p class="p12">}</p>
</ol>
<p class="p5"><span class="s3"><b>Exercise 12. 修改 mon_backtrace 使得其能够打印出</b></span><span class="s21"><b>当前所在的文件、行号和函数</b></span><span class="s3"><b>（更方便的查看函数调用栈，以及当程序出错时能够更方便的知道哪些函数可能存在 bug）</b> </span></p>
<p class="p2">【<span class="s4">TODO</span>】符号表理解，这个如何做的，通过查看<span class="s4"> <b>debuginfo_eip</b> </span>函数实现大致知道怎么处理，但为什么是这样需要理解？</p>
<ol class="ol1">
  <li class="li3"><span class="s1"></span><b>debuginfo_eip</b> <span class="s1">函数中添加行号查找</span></li>
<p class="p22"><br></p>
<p class="p23">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</p>
<p class="p23">    if (lline &lt;= rline) {</p>
<p class="p23">        info-&gt;eip_line = stabs[lline].<b>n_desc</b>;</p>
<p class="p23">    } else {</p>
<p class="p23">        return -1;</p>
<p class="p23">    }</p>
<p class="p22"><br></p>
  <li class="li3"><span class="s16"></span><span class="s1">在</span> <b>mon_trace</b> <span class="s1">函数中加入：</span></li>
<p class="p22"><br></p>
<p class="p31"><span class="s8">        // </span>打印额外的信息：所在文件<span class="s8">:</span>行数<span class="s8">:</span>所在函数</p>
<p class="p23">        struct Eipdebuginfo info;</p>
<p class="p23">        if (<b>debuginfo_eip</b>(eip, &amp;info) == 0)<span class="Apple-converted-space"> </span></p>
<p class="p23">            cprintf("<span class="Apple-converted-space">    </span>%s:%d: %.*s+%u\n", info.eip_file, info.eip_line,<span class="Apple-converted-space"> </span></p>
<p class="p23">                info.eip_fn_namelen, info.eip_fn_name,</p>
<p class="p23">                (uint32_t)(eip - info.eip_fn_addr));</p>
<p class="p23">        else</p>
<p class="p23">            cprintf("Error happened when reading symbol table\n");</p>
</ol>
<p class="p22"><br></p>
<p class="p32"><br></p>
<p class="p33"><b>主要参考</b><span class="s9">：</span></p>
<ul class="ul2">
  <li class="li34"><span class="s4"><a href="http://grid.hust.edu.cn/zyshao/Teaching_Material/OSEngineering/Chapter3.pdf"><span class="s1">系统启动与初始化</span></a></span> 华科的一个老师的课程讲义，巨细无遗，本文大量参考这篇文档</li>
  <li class="li34"><span class="s4"><a href="https://book.douban.com/subject/3652388/"><span class="s1">程序员的自我修养：装载、链接与库</span></a></span> 国人写的一本书，分析的很详细，很有实践意义
  <ul class="ul1">
    <li class="li34">第 2 章 编译与链接 2.4 模块拼装——静态链接</li>
    <li class="li34">第 3 章 目标文件里有什么</li>
    <li class="li34">第 4 章 静态链接</li>
  </ul></li>
  <li class="li1"><span class="s4"><a href="https://book.douban.com/subject/26912767/"><span class="s1">深入理解计算机系统</span></a> </span>第<span class="s4"> 7 </span>章<span class="s4"> </span>链接<span class="s4"> </span>之前看过好几遍，需要理解</li>
  <li class="li1"><span class="s4"><a href="https://www.zhihu.com/question/58121772/answer/156287959">Linux <span class="s1">内核应该怎么去学习？</span></a> </span>如陈硕所说，<span class="s4">“</span>学习操作系统要注意区分共性与平台特性<span class="s4">”</span></li>
  <li class="li1"><span class="s4"><a href="https://segmentfault.com/a/1190000007977460">C<span class="s1">函数调用过程原理及函数栈帧分析</span></a> </span><span class="s16">函数</span>调用和栈帧讲解的很清晰</li>
</ul>
<p class="p32"><br></p>
<p class="p32"><br></p>
